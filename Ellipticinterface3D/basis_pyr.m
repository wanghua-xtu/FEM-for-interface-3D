function [Tet1_phi,Tet2_phi,t1_gradphi,t2_gradphi,pxyz1,pxyz2,JF1,JF2] = basis_pyr(elem,node,lambdap)
%% basis_pyr return composite trilinear pyramidal basis 
% Divide the pyramid into two Tetrahedrons and use the Tetrahedron numerical integration formula
% node  = [0 0 0; 1 0 0; 1 1 0; 0 1 0; 
%          0 0 1; 1 0 1; 1 1 1; 0 1 1];
% elem = [1 2 3 4 5; 6 5 8 7 2; 2 1 5 6 3];
%         
% % node = [0 0 0; 1 0 0; 1 1/2 0; 0 1 0; 0 0 1];
% % elem = [1 2 3 4 5];
% [lambda,weight] = quadpts3(3); %numerical integration formula on Tetrahedral 
% p =2;
% lambdap = lambda(p,:);
% Tet1 = elem(:,[1 2 3 5]);
% Tet2 = elem(:,[1 3 4 5]);
% Tet1_node = [0 0 0]
%
x = [node(elem(:,1),1),node(elem(:,2),1),node(elem(:,3),1),node(elem(:,4),1),node(elem(:,5),1)];
y = [node(elem(:,1),2),node(elem(:,2),2),node(elem(:,3),2),node(elem(:,4),2),node(elem(:,5),2)];
z = [node(elem(:,1),3),node(elem(:,2),3),node(elem(:,3),3),node(elem(:,4),3),node(elem(:,5),3)];
% 单元体积
% VTet1 = ((x(:,2)-x(:,1)).*((y(:,3)-y(:,1)).*(z(:,5)-z(:,1))-(y(:,5)-y(:,1)).*(z(:,3)-z(:,1))) ...
%     -(x(:,3)-x(:,1)).*((y(:,2)-y(:,1)).*(z(:,5)-z(:,1))-(y(:,5)-y(:,1)).*(z(:,2)-z(:,1))) ...
%     +(x(:,5)-x(:,1)).*((y(:,2)-y(:,1)).*(z(:,3)-z(:,1))-(y(:,3)-y(:,1)).*(z(:,2)-z(:,1))))/6;
% VTet2 = ((x(:,3)-x(:,1)).*((y(:,4)-y(:,1)).*(z(:,5)-z(:,1))-(y(:,5)-y(:,1)).*(z(:,4)-z(:,1))) ...
%     -(x(:,4)-x(:,1)).*((y(:,3)-y(:,1)).*(z(:,5)-z(:,1))-(y(:,5)-y(:,1)).*(z(:,3)-z(:,1))) ...
%     +(x(:,5)-x(:,1)).*((y(:,3)-y(:,1)).*(z(:,4)-z(:,1))-(y(:,4)-y(:,1)).*(z(:,3)-z(:,1))))/6;

%积分点对应的直角坐标，主要是右端项f的积分需要
pxyz1 = lambdap(1)*node(elem(:,1),:) ...
      + lambdap(2)*node(elem(:,2),:) ... 
      + lambdap(3)*node(elem(:,3),:) ... 
      + lambdap(4)*node(elem(:,5),:);
  
pxyz2 = lambdap(1)*node(elem(:,1),:) ...
      + lambdap(2)*node(elem(:,3),:) ... 
      + lambdap(3)*node(elem(:,4),:) ... 
      + lambdap(4)*node(elem(:,5),:);
  
%value of phi and gradphi on reference element 
XYZ1 = lambdap*[0 0 0;1 0 0;1 1 0;0 0 1];
XYZ2 = lambdap*[0 0 0;1 1 0;0 1 0;0 0 1];

X1 = XYZ1(1); Y1 = XYZ1(2); Z1 = XYZ1(3);
X2 = XYZ2(1); Y2 = XYZ2(2); Z2 = XYZ2(3);
Tet1_phi = [(1-X1)*(1-Y1)+(Y1-1)*Z1;
            X1*(1-Y1)-Y1*Z1;
            X1*Y1+Y1*Z1;
            (1-X1)*Y1-Y1*Z1;
            Z1];
Tet2_phi = [(1-X2)*(1-Y2)+(X2-1)*Z2;
             X2*(1-Y2)-X2*Z2;
             X2*Y2+X2*Z2;
             (1-X2)*Y2-X2*Z2;
             Z2];

Tet1_gradphi = [Y1-1, X1+Z1-1, Y1-1; 1-Y1, -X1-Z1, -Y1; 
                Y1, X1+Z1, Y1; -Y1, 1-X1-Z1, -Y1; 0  0  1]';
            
Tet2_gradphi = [Y2+Z2-1, X2-1, X2-1; 1-Y2-Z2, -X2, -X2; 
                Y2+Z2, X2, X2; -Y2-Z2, 1-X2, -X2; 0  0  1]';
            
%Jacobian matrix of the transformation(3*3的矩阵拉成行向量)
DF1 = [ Y1*x(:,3) - Y1*x(:,4) + x(:,1)*(Y1 - 1) - x(:,2)*(Y1 - 1), ...
        x(:,1)*(X1 + Z1 - 1) - x(:,2)*(X1 + Z1) + x(:,3)*(X1 + Z1) - x(:,4)*(X1 + Z1 - 1), ...
        x(:,5) - Y1*x(:,2) + Y1*x(:,3) - Y1*x(:,4) + x(:,1)*(Y1 - 1), ...
        Y1*y(:,3) - Y1*y(:,4) + y(:,1)*(Y1 - 1) - y(:,2)*(Y1 - 1), ...
        y(:,1)*(X1 + Z1 - 1) - y(:,2)*(X1 + Z1) + y(:,3)*(X1 + Z1) - y(:,4)*(X1 + Z1 - 1),...
        y(:,5) - Y1*y(:,2) + Y1*y(:,3) - Y1*y(:,4) + y(:,1)*(Y1 - 1), ...
        Y1*z(:,3) - Y1*z(:,4) + z(:,1)*(Y1 - 1) - z(:,2)*(Y1 - 1), ...
        z(:,1)*(X1 + Z1 - 1) - z(:,2)*(X1 + Z1) + z(:,3)*(X1 + Z1) - z(:,4)*(X1 + Z1 - 1),...
        z(:,5) - Y1*z(:,2) + Y1*z(:,3) - Y1*z(:,4) + z(:,1)*(Y1 - 1)];
 
    
DF2 = [ x(:,1)*(Y2 + Z2 - 1) - x(:,2)*(Y2 + Z2 - 1) + x(:,3)*(Y2 + Z2) - x(:,4)*(Y2 + Z2), ...
        X2*x(:,3) - X2*x(:,2) + x(:,1)*(X2 - 1) - x(:,4)*(X2 - 1), ...
        x(:,5) - X2*x(:,2) + X2*x(:,3) - X2*x(:,4) + x(:,1)*(X2 - 1), ...
        y(:,1)*(Y2 + Z2 - 1) - y(:,2)*(Y2 + Z2 - 1) + y(:,3)*(Y2 + Z2) - y(:,4)*(Y2 + Z2), ...
        X2*y(:,3) - X2*y(:,2) + y(:,1)*(X2 - 1) - y(:,4)*(X2 - 1), ...
        y(:,5) - X2*y(:,2) + X2*y(:,3) - X2*y(:,4) + y(:,1)*(X2 - 1), ...
        z(:,1)*(Y2 + Z2 - 1) - z(:,2)*(Y2 + Z2 - 1) + z(:,3)*(Y2 + Z2) - z(:,4)*(Y2 + Z2),...
        X2*z(:,3) - X2*z(:,2) + z(:,1)*(X2 - 1) - z(:,4)*(X2 - 1),...
        z(:,5) - X2*z(:,2) + X2*z(:,3) - X2*z(:,4) + z(:,1)*(X2 - 1)];
 
 JF1  = DF1(:,1).*DF1(:,5).*DF1(:,9) - DF1(:,1).*DF1(:,6).*DF1(:,8) - DF1(:,2).*DF1(:,4).*DF1(:,9) ...
       + DF1(:,2).*DF1(:,6).*DF1(:,7) + DF1(:,3).*DF1(:,4).*DF1(:,8) - DF1(:,3).*DF1(:,5).*DF1(:,7);
 adjtranDF1 = [ DF1(:,5).*DF1(:,9) - DF1(:,6).*DF1(:,8), DF1(:,6).*DF1(:,7) - DF1(:,4).*DF1(:,9), DF1(:,4).*DF1(:,8) - DF1(:,5).*DF1(:,7), ...
            DF1(:,3).*DF1(:,8) - DF1(:,2).*DF1(:,9), DF1(:,1).*DF1(:,9) - DF1(:,3).*DF1(:,7), DF1(:,2).*DF1(:,7) - DF1(:,1).*DF1(:,8), ...
            DF1(:,2).*DF1(:,6) - DF1(:,3).*DF1(:,5), DF1(:,3).*DF1(:,4) - DF1(:,1).*DF1(:,6), DF1(:,1).*DF1(:,5) - DF1(:,2).*DF1(:,4)];

 JF2  = DF2(:,1).*DF2(:,5).*DF2(:,9) - DF2(:,1).*DF2(:,6).*DF2(:,8) - DF2(:,2).*DF2(:,4).*DF2(:,9) ...
       + DF2(:,2).*DF2(:,6).*DF2(:,7) + DF2(:,3).*DF2(:,4).*DF2(:,8) - DF2(:,3).*DF2(:,5).*DF2(:,7);
 adjtranDF2 = [ DF2(:,5).*DF2(:,9) - DF2(:,6).*DF2(:,8), DF2(:,6).*DF2(:,7) - DF2(:,4).*DF2(:,9), DF2(:,4).*DF2(:,8) - DF2(:,5).*DF2(:,7), ...
            DF2(:,3).*DF2(:,8) - DF2(:,2).*DF2(:,9), DF2(:,1).*DF2(:,9) - DF2(:,3).*DF2(:,7), DF2(:,2).*DF2(:,7) - DF2(:,1).*DF2(:,8), ...
            DF2(:,2).*DF2(:,6) - DF2(:,3).*DF2(:,5), DF2(:,3).*DF2(:,4) - DF2(:,1).*DF2(:,6), DF2(:,1).*DF2(:,5) - DF2(:,2).*DF2(:,4)];
t1_gradphi = zeros(size(elem,1),3,5);
t2_gradphi = zeros(size(elem,1),3,5);
for i = 1:5
    t1_gradphi(:,:,i) = [adjtranDF1(:,1:3)*Tet1_gradphi(:,i)./JF1, ...
                         adjtranDF1(:,4:6)*Tet1_gradphi(:,i)./JF1, ...
                         adjtranDF1(:,7:9)*Tet1_gradphi(:,i)./JF1];
    t2_gradphi(:,:,i) = [adjtranDF2(:,1:3)*Tet2_gradphi(:,i)./JF2, ...
                         adjtranDF2(:,4:6)*Tet2_gradphi(:,i)./JF2, ...
                         adjtranDF2(:,7:9)*Tet2_gradphi(:,i)./JF2];
end